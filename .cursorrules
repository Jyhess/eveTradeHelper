# DEVELOPMENT RULES - TO BE SYSTEMATICALLY FOLLOWED

‚ö†Ô∏è **IMPORTANT**: These rules are MANDATORY. The AI must ALWAYS respect them when making any code modifications.

## Test-Driven Development (TDD)

**ALL** code modifications (backend AND frontend) must follow the TDD Red-Green-Refactor cycle:

### 1. üî¥ RED - Write the failing test

**MANDATORY STEP**: Write the test BEFORE implementing the feature.

- The test must fail for the right reason (no missing imports, etc.)
- The test must be specific and test one thing
- **DO NOT** implement code without writing the test first

### 2. üü¢ GREEN - Implement the minimum to make the test pass

**MANDATORY STEP**: Implement only the minimum necessary.

- Implement only what is necessary for the test to pass
- **DO NOT** add additional features
- Code can be "dirty" as long as the test passes

### 3. üîµ REFACTOR - Improve the code

**MANDATORY STEP**: Refactor after the test passes.

- Once the test is green, refactor the code
- Improve readability, performance, maintainability
- Ensure all tests still pass after refactoring
- Apply all clean code rules below

## Project-specific rules

### Language

**ABSOLUTE RULE**: **ALWAYS** write in English.

**MANDATORY ACTION**:

- All code, comments, docstrings, documentation, and messages must be in English
- Variable names, function names, class names must be in English
- Error messages, log messages, and user-facing text must be in English
- Documentation files (README, ARCHITECTURE, DEBUG, etc.) must be in English
- Test names and test descriptions must be in English

**VIOLATION EXAMPLE**:

```python
# ‚ùå BAD
def calculer_volume():
    """Calcule le volume d'un item"""
    # R√©cup√©rer les donn√©es
    pass

# ‚úÖ GOOD
def calculate_volume():
    """Calculates the volume of an item"""
    # Retrieve data
    pass
```

## BACKEND-SPECIFIC RULES

### Backend Tests

- Unit tests do NOT use Redis cache
- Integration tests use shared Redis cache. Do not clean cache between tests (shared with production).
- Use `pytest.mark.parametrize` to avoid code duplication in tests

### Backend Code

- Respect Python types (typing)
- Use explicit variable and function names

## CLEAN CODE RULES - TO BE SYSTEMATICALLY APPLIED

**ALL** code modifications must respect the following clean code principles. The AI must verify each rule before proposing code.

### 1. Elimination of magic numbers and strings

**ABSOLUTE RULE**: **NEVER** use magic numbers or strings directly in code.

**MANDATORY ACTION**:

- **Backend**: Create named constants in `backend/domain/constants.py`
  - Examples: `STATION_ID_THRESHOLD = 60000000`, `DEFAULT_MIN_PROFIT_ISK = 100000.0`
- **Frontend**: Create named constants in `frontend/src/constants.js`
  - Examples: `API_TIMEOUT_MS = 10000`, `DEFAULT_PAGE_SIZE = 50`, `ROUTES = { REGIONS: '/regions' }`
- Constants must be explicit and documented

**VIOLATION EXAMPLE**:

```python
# ‚ùå BAD
if station_id > 60000000:
    # ...

# ‚úÖ GOOD
from domain.constants import STATION_ID_THRESHOLD
if station_id > STATION_ID_THRESHOLD:
    # ...
```

### 2. Small Functions and Components

**ABSOLUTE RULE**: A function or component must do **one thing** (Single Responsibility Principle).

**MANDATORY ACTION**:

- **Backend**: If a function exceeds 50 lines, **DIVIDE IT** into sub-functions
- **Frontend**: If a function exceeds 50 lines OR a component exceeds 200 lines, **DIVIDE IT**
- Functions and components must be individually testable
- Prefer several small functions/components over one large one

**VIOLATION EXAMPLE**:

```python
# ‚ùå BAD: 60-line function
def process_data(data):
    # 60 lines of code...
    pass

# ‚úÖ GOOD: divided into sub-functions
def process_data(data):
    validated = validate_data(data)
    cleaned = clean_data(validated)
    return transform_data(cleaned)
```

### 3. Meaningful Names

- Variable, function, and class names must be **self-explanatory**
- Avoid abbreviations unless they are universal (e.g., `id`, `api`)
- Use verbs for functions: `calculate_volume()`, `get_item_type()`
- Use domain business names when appropriate

### 4. DRY (Don't Repeat Yourself)

**ABSOLUTE RULE**: **NEVER** duplicate code.

**MANDATORY ACTION**:

- **Backend**: Extract common logic into utility functions in `backend/domain/helpers.py` or `backend/utils/`
- **Frontend**: Extract common logic into utility functions in `frontend/src/utils/` or create reusable components
- Reuse existing functions/components rather than rewriting logic
- If code is repeated 2 times or more, extract it into a function/component

### 4.1. Prefer named functions over comments

- **NEVER** use a comment to explain what a complex line of code does
- Extract logic into an explicit named function
- Example: replace `# Filter valid results and None` + `deals = [r for r in results if isinstance(r, dict) and r is not None]` with `deals = filter_valid_deals(results)`
- Named functions are self-documented and reusable
- If a line of code requires a comment, it's a sign it should be extracted into a function

### 5. Single Responsibility Principle (SRP)

- Each class/function must have **one reason to change**
- Separate concerns: collection, calculation, formatting, etc.
- Extract complex logic into private methods (`_method_name`)

### 6. Encapsulation and abstraction

- **Backend**: **Hide implementation details** of lower layers
  - APIs must **NEVER** directly access repositories
  - Create methods in services to encapsulate repository access
  - Respect layered architecture (API ‚Üí Service ‚Üí Repository)
- **Frontend**: **Hide implementation details** of services
  - Components must **NEVER** directly make API calls
  - All API calls must go through services in `frontend/src/services/`
  - Components should focus on presentation and user interaction

### 7. Documentation and expressiveness

- **Backend**: Add **docstrings** only when necessary:
  - **ALWAYS** in APIs (FastAPI endpoints) to generate OpenAPI documentation
  - **AVOID** redundant docstrings in business code if the name and parameters are clear
- **Frontend**: Add **JSDoc** only when necessary:
  - **ALWAYS** for public API functions in services
  - **AVOID** redundant JSDoc in components if the name and parameters are clear
- If a function requires a docstring/JSDoc, it may be a sign that naming can be improved
- Use comments to explain the **why**, not the **how**
- Code must be self-documented through good naming
- A docstring/JSDoc is useless if it simply repeats the function name and its parameters

### 8. Separation of concerns

- **Backend**:
  - Separate constants in `backend/domain/constants.py`
  - Separate utilities in `backend/domain/helpers.py` when module-specific, in `backend/utils/` when shared
  - Business logic must be in services, not in APIs
- **Frontend**:
  - Separate constants in `frontend/src/constants.js`
  - Separate utilities in `frontend/src/utils/` when module-specific
  - Business logic must be in services (`frontend/src/services/`), not in components
  - Components should focus on presentation and user interaction
- Each module must have a clear responsibility

### 9. Appropriate abstraction

- Use the **right level of abstraction** for each function
- Create reusable utility functions instead of inline logic
- Avoid mixed abstraction levels in the same function

### 10. Maintainability

- Code must be **easy to modify** without breaking other parts
- Centralize constants to facilitate changes
- Structure code in a modular way
- Prefer composition over duplication

### 11. Import management

**ABSOLUTE RULE**: **NEVER** import inside functions.

**MANDATORY ACTION**:

- All imports must be **AT THE TOP OF THE FILE** only
- Group imports: standard library, third-party, local
- Use absolute imports for project modules

**VIOLATION EXAMPLE**:

```python
# ‚ùå BAD
def my_function():
    import logging  # ‚ùå Import inside function
    logging.info("test")

# ‚úÖ GOOD
import logging  # ‚úÖ Import at top of file

def my_function():
    logging.info("test")
```

### 12. Error handling

- Avoid generic `except Exception` when possible
- Log errors with appropriate context
- Use specific exceptions when possible
- Do not hide errors without logging them

## FRONTEND-SPECIFIC RULES

### Frontend Tests

- Unit tests use Jest/Vitest with Vue Test Utils
- Component tests should test behavior, not implementation details
- Use `@vue/test-utils` for component testing
- Mock API calls in unit tests
- Integration tests can use real API calls (if needed)
- Use `describe` and `it` blocks for test organization
- Use descriptive test names that explain what is being tested

### Frontend Code

- Use ES6+ features (const/let, arrow functions, destructuring, etc.)
- Use explicit variable and function names
- Prefer composition over inheritance
- Use Vue 3 Composition API when appropriate (for complex components)

### Vue-Specific Best Practices

**MANDATORY ACTION**:

- Use `v-if` for conditional rendering (not `v-show` unless performance is critical)
- Use `:key` for `v-for` loops with unique identifiers
- Use computed properties for derived state (not methods)
- Use methods for event handlers and actions
- Avoid direct DOM manipulation - use Vue's reactivity system
- Use props for parent-to-child communication
- Use events (`$emit`) for child-to-parent communication
- Use Vuex/Pinia or provide/inject for global state (if needed)
- Use `scoped` styles to avoid CSS conflicts
- Prefer template refs over direct DOM queries

### Component Structure

**MANDATORY ACTION**:

- Follow Vue component structure: `<template>`, `<script>`, `<style>`
- Organize script section: props, data, computed, methods, lifecycle hooks
- Use single-file components (`.vue` files)
- Keep template logic minimal - move complex logic to computed properties or methods
- Use scoped styles when possible to avoid style conflicts

### API Service Pattern

**MANDATORY ACTION**:

- All API calls must go through services in `frontend/src/services/`
- Services must handle errors and transform data
- Components must not contain API logic
- Use async/await for asynchronous operations
- Handle loading and error states in components

## MANDATORY CHECKLIST BEFORE ANY CODE MODIFICATION

**THE AI MUST verify this checklist before proposing code**:

### Backend Checklist

- [ ] **TDD respected**: Test written BEFORE implementation (RED ‚Üí GREEN ‚Üí REFACTOR)
- [ ] **No magic numbers**: Use constants from `backend/domain/constants.py`
- [ ] **Small functions**: No function exceeds 50 lines
- [ ] **Explicit names**: Self-explanatory variables and functions
- [ ] **No duplication**: Code reused via helper functions
- [ ] **Named functions**: No explanatory comments, extract into functions
- [ ] **SRP respected**: Single responsibility per function/class
- [ ] **Encapsulation**: No direct repository access from APIs
- [ ] **Docstrings**: Only in APIs (FastAPI) and if really necessary
- [ ] **Imports at top**: All imports at top of file only
- [ ] **Business logic**: In services, not in APIs
- [ ] **Error handling**: Specific exceptions, no generic `except Exception`
- [ ] **Ruff formatting**: Execute `ruff format` on all modified backend files after each modification
- [ ] **Ruff linting**: Execute `ruff check --fix` on all modified backend files after each modification
- [ ] **Type checking**: Run `mypy` to verify type correctness (if applicable)
- [ ] **Tests passing**: All tests must pass with `pytest`
- [ ] **English language**: All code, comments, docstrings, and documentation in English

### Frontend Checklist

- [ ] **TDD respected**: Test written BEFORE implementation (RED ‚Üí GREEN ‚Üí REFACTOR)
- [ ] **No magic numbers/strings**: Use constants from `frontend/src/constants.js`
- [ ] **Small functions/components**: No function exceeds 50 lines, no component exceeds 200 lines
- [ ] **Explicit names**: Self-explanatory variables, functions, and components
- [ ] **No duplication**: Code reused via helper functions or components
- [ ] **Named functions**: No explanatory comments, extract into functions
- [ ] **SRP respected**: Single responsibility per function/component
- [ ] **Component structure**: Proper Vue component organization
- [ ] **JSDoc**: Only in services (public APIs) and if really necessary
- [ ] **Imports at top**: All imports at top of file only
- [ ] **Business logic**: In services, not in components
- [ ] **Error handling**: Specific error handling, no generic catch
- [ ] **Vue best practices**: Proper use of v-if, :key, computed, methods, etc.
- [ ] **API calls**: Through services only, not in components
- [ ] **ESLint**: Execute `npm run lint -- --fix` on all modified frontend files after each modification
- [ ] **Tests passing**: All tests must pass with `npm test`
- [ ] **English language**: All code, comments, JSDoc, and documentation in English

## INSTRUCTIONS FOR THE AI

**BEFORE proposing code, THE AI MUST**:

1. **Read this complete checklist**
2. **Verify each point** before generating code
3. **Systematically apply** all rules
4. **Write everything in English** (code, comments, docstrings, documentation)
5. **Refuse** to generate code that violates these rules
6. **Propose corrections** if existing code violates the rules

## CODE QUALITY TOOLS

### Backend Tools

**MANDATORY TOOLS**:

1. **Ruff** - Linting and formatting
   - **Configuration**: `backend/pyproject.toml`
   - **Formatting**: `ruff format <file>`
   - **Linting**: `ruff check <file>`
   - **Auto-fix**: `ruff check --fix <file>`
   - **Rules**: E, W, F, I, N, UP, B, C4, SIM (see pyproject.toml)
   - **Line length**: 100 characters

2. **MyPy** - Type checking
   - **Configuration**: `backend/pyproject.toml`
   - **Command**: `mypy <file>` or `mypy backend/`
   - **Purpose**: Static type checking for Python

3. **Pytest** - Testing framework
   - **Configuration**: `backend/pytest.ini`
   - **Command**: `pytest` or `pytest <test_file>`
   - **Coverage**: Use `pytest-cov` for coverage reports

**MANDATORY ACTIONS**:

- **ALWAYS** run `ruff format` after modifying Python files
- **ALWAYS** run `ruff check` to verify linting rules
- Run `mypy` before committing to catch type errors
- Ensure all tests pass with `pytest`

**COMMON COMMANDS**:

```bash
# Format code
ruff format backend/path/to/file.py

# Check and auto-fix linting issues
ruff check --fix backend/path/to/file.py

# Type checking
mypy backend/path/to/file.py

# Run all tests
pytest

# Run specific test file
pytest backend/unit_tests/test_file.py

# Run with coverage
pytest --cov=backend --cov-report=html
```

### Frontend Tools

**MANDATORY TOOLS**:

1. **ESLint** - Linting for JavaScript/Vue
   - **Configuration**: Should be configured in `package.json` or `.eslintrc.js`
   - **Command**: `npm run lint` or `eslint <file>`
   - **Auto-fix**: `npm run lint -- --fix` or `eslint --fix <file>`
   - **Purpose**: Code quality and style enforcement

2. **Prettier** - Code formatting (if configured)
   - **Configuration**: `.prettierrc` or `package.json`
   - **Command**: `prettier --write <file>`
   - **Purpose**: Consistent code formatting

3. **Vue Test Utils** - Component testing
   - **Framework**: Jest/Vitest with Vue Test Utils
   - **Command**: `npm test` or `npm run test:unit`
   - **Purpose**: Unit testing for Vue components

**MANDATORY ACTIONS**:

- **ALWAYS** run `npm run lint -- --fix` after modifying JavaScript/Vue files
- Ensure ESLint configuration is set up in the project
- Run tests before committing: `npm test`
- Verify code formatting is consistent

**COMMON COMMANDS**:

```bash
# Lint and auto-fix
npm run lint -- --fix

# Lint specific file
npm run lint -- src/path/to/file.vue

# Run tests
npm test

# Run tests in watch mode
npm run test:watch

# Run tests with coverage
npm run test:coverage

# Format with Prettier (if configured)
npx prettier --write src/path/to/file.vue
```

**AFTER modifying code, THE AI MUST**:

1. **Backend**: **Automatically execute Ruff format and check** on all modified Python files
   - **Formatting**: `ruff format <file1> <file2> ...` for each modified file in `backend/`
   - **Linting**: `ruff check <file1> <file2> ...` for each modified file
   - **Auto-fix**: `ruff check --fix <file1> <file2> ...` if linting errors are found
   - **Verify** that formatting and linting pass before finalizing modifications
   - **Never** propose code not formatted with Ruff or with linting errors

2. **Frontend**: **Automatically execute ESLint/Prettier** on all modified JavaScript/Vue files
   - **Command to execute**: `npm run lint -- --fix <file1> <file2> ...` for each modified file in `frontend/src/`
   - **Verify** that linting passes and formatting is applied before finalizing modifications
   - **Never** propose code not formatted according to project standards or with linting errors

**If the user requests something that violates these rules, THE AI MUST**:

- Explain why the request violates the rules
- Propose an alternative that complies with the rules
- Not generate non-compliant code
