# DEVELOPMENT RULES - TO BE SYSTEMATICALLY FOLLOWED

‚ö†Ô∏è **IMPORTANT**: These rules are MANDATORY. The AI must ALWAYS respect them when making any code modifications.

## Test-Driven Development (TDD)

**ALL** code modifications on the backend must follow the TDD Red-Green-Refactor cycle:

### 1. üî¥ RED - Write the failing test

**MANDATORY STEP**: Write the test BEFORE implementing the feature.

- The test must fail for the right reason (no missing imports, etc.)
- The test must be specific and test one thing
- **DO NOT** implement code without writing the test first

### 2. üü¢ GREEN - Implement the minimum to make the test pass

**MANDATORY STEP**: Implement only the minimum necessary.

- Implement only what is necessary for the test to pass
- **DO NOT** add additional features
- Code can be "dirty" as long as the test passes

### 3. üîµ REFACTOR - Improve the code

**MANDATORY STEP**: Refactor after the test passes.

- Once the test is green, refactor the code
- Improve readability, performance, maintainability
- Ensure all tests still pass after refactoring
- Apply all clean code rules below

## Project-specific rules

### Language

**ABSOLUTE RULE**: **ALWAYS** write in English.

**MANDATORY ACTION**:

- All code, comments, docstrings, documentation, and messages must be in English
- Variable names, function names, class names must be in English
- Error messages, log messages, and user-facing text must be in English
- Documentation files (README, ARCHITECTURE, DEBUG, etc.) must be in English
- Test names and test descriptions must be in English

**VIOLATION EXAMPLE**:

```python
# ‚ùå BAD
def calculer_volume():
    """Calcule le volume d'un item"""
    # R√©cup√©rer les donn√©es
    pass

# ‚úÖ GOOD
def calculate_volume():
    """Calculates the volume of an item"""
    # Retrieve data
    pass
```

### Tests

- Unit tests do NOT use Redis cache
- Integration tests use shared Redis cache. Do not clean cache between tests (shared with production).
- Use `pytest.mark.parametrize` to avoid code duplication in tests

### Code

- Respect Python types (typing)
- Use explicit variable and function names

## CLEAN CODE RULES - TO BE SYSTEMATICALLY APPLIED

**ALL** code modifications must respect the following clean code principles. The AI must verify each rule before proposing code.

### 1. Elimination of magic numbers

**ABSOLUTE RULE**: **NEVER** use magic numbers directly in code.

**MANDATORY ACTION**:

- Create named constants in `backend/domain/constants.py`
- Examples: `STATION_ID_THRESHOLD = 60000000`, `DEFAULT_MIN_PROFIT_ISK = 100000.0`
- Constants must be explicit and documented

**VIOLATION EXAMPLE**:

```python
# ‚ùå BAD
if station_id > 60000000:
    # ...

# ‚úÖ GOOD
from domain.constants import STATION_ID_THRESHOLD
if station_id > STATION_ID_THRESHOLD:
    # ...
```

### 2. Small Functions

**ABSOLUTE RULE**: A function must do **one thing** (Single Responsibility Principle).

**MANDATORY ACTION**:

- If a function exceeds 50 lines, **DIVIDE IT** into sub-functions
- Functions must be individually testable
- Prefer several small functions over one large function

**VIOLATION EXAMPLE**:

```python
# ‚ùå BAD: 60-line function
def process_data(data):
    # 60 lines of code...
    pass

# ‚úÖ GOOD: divided into sub-functions
def process_data(data):
    validated = validate_data(data)
    cleaned = clean_data(validated)
    return transform_data(cleaned)
```

### 3. Meaningful Names

- Variable, function, and class names must be **self-explanatory**
- Avoid abbreviations unless they are universal (e.g., `id`, `api`)
- Use verbs for functions: `calculate_volume()`, `get_item_type()`
- Use domain business names when appropriate

### 4. DRY (Don't Repeat Yourself)

**ABSOLUTE RULE**: **NEVER** duplicate code.

**MANDATORY ACTION**:

- Extract common logic into utility functions
- Create helpers in `backend/domain/helpers.py` if necessary
- Reuse existing functions rather than rewriting logic
- If code is repeated 2 times or more, extract it into a function

### 4.1. Prefer named functions over comments

- **NEVER** use a comment to explain what a complex line of code does
- Extract logic into an explicit named function
- Example: replace `# Filter valid results and None` + `deals = [r for r in results if isinstance(r, dict) and r is not None]` with `deals = filter_valid_deals(results)`
- Named functions are self-documented and reusable
- If a line of code requires a comment, it's a sign it should be extracted into a function

### 5. Single Responsibility Principle (SRP)

- Each class/function must have **one reason to change**
- Separate concerns: collection, calculation, formatting, etc.
- Extract complex logic into private methods (`_method_name`)

### 6. Encapsulation and abstraction

- **Hide implementation details** of lower layers
- APIs must **NEVER** directly access repositories
- Create methods in services to encapsulate repository access
- Respect layered architecture (API ‚Üí Service ‚Üí Repository)

### 7. Documentation and expressiveness

- Add **docstrings** only when necessary:
  - **ALWAYS** in APIs (FastAPI endpoints) to generate OpenAPI documentation
  - **AVOID** redundant docstrings in business code if the name and parameters are clear
- If a function requires a docstring, it may be a sign that naming can be improved
- Use comments to explain the **why**, not the **how**
- Code must be self-documented through good naming
- A docstring is useless if it simply repeats the function name and its parameters

### 8. Separation of concerns

- Separate constants in `constants.py`
- Separate utilities in `helpers.py` when module-specific, in `backend/utils` when shared between multiple modules.
- Business logic must be in services, not in APIs
- Each module must have a clear responsibility

### 9. Appropriate abstraction

- Use the **right level of abstraction** for each function
- Create reusable utility functions instead of inline logic
- Avoid mixed abstraction levels in the same function

### 10. Maintainability

- Code must be **easy to modify** without breaking other parts
- Centralize constants to facilitate changes
- Structure code in a modular way
- Prefer composition over duplication

### 11. Import management

**ABSOLUTE RULE**: **NEVER** import inside functions.

**MANDATORY ACTION**:

- All imports must be **AT THE TOP OF THE FILE** only
- Group imports: standard library, third-party, local
- Use absolute imports for project modules

**VIOLATION EXAMPLE**:

```python
# ‚ùå BAD
def my_function():
    import logging  # ‚ùå Import inside function
    logging.info("test")

# ‚úÖ GOOD
import logging  # ‚úÖ Import at top of file

def my_function():
    logging.info("test")
```

### 12. Error handling

- Avoid generic `except Exception` when possible
- Log errors with appropriate context
- Use specific exceptions when possible
- Do not hide errors without logging them

## MANDATORY CHECKLIST BEFORE ANY CODE MODIFICATION

**THE AI MUST verify this checklist before proposing code**:

- [ ] **TDD respected**: Test written BEFORE implementation (RED ‚Üí GREEN ‚Üí REFACTOR)
- [ ] **No magic numbers**: Use constants from `backend/domain/constants.py`
- [ ] **Small functions**: No function exceeds 50 lines
- [ ] **Explicit names**: Self-explanatory variables and functions
- [ ] **No duplication**: Code reused via helper functions
- [ ] **Named functions**: No explanatory comments, extract into functions
- [ ] **SRP respected**: Single responsibility per function/class
- [ ] **Encapsulation**: No direct repository access from APIs
- [ ] **Docstrings**: Only in APIs (FastAPI) and if really necessary
- [ ] **Imports at top**: All imports at top of file only
- [ ] **Business logic**: In services, not in APIs
- [ ] **Error handling**: Specific exceptions, no generic `except Exception`
- [ ] **Ruff formatting**: Execute `ruff format` on all modified backend files after each modification
- [ ] **English language**: All code, comments, docstrings, and documentation in English

## INSTRUCTIONS FOR THE AI

**BEFORE proposing code, THE AI MUST**:

1. **Read this complete checklist**
2. **Verify each point** before generating code
3. **Systematically apply** all rules
4. **Write everything in English** (code, comments, docstrings, documentation)
5. **Refuse** to generate code that violates these rules
6. **Propose corrections** if existing code violates the rules

**AFTER modifying code in the backend, THE AI MUST**:

1. **Automatically execute Ruff format** on all modified Python files
2. **Command to execute**: `ruff format <file1> <file2> ...` for each modified file in `backend/`
3. **Verify** that formatting is applied before finalizing modifications
4. **Never** propose code not formatted with Ruff

**If the user requests something that violates these rules, THE AI MUST**:

- Explain why the request violates the rules
- Propose an alternative that complies with the rules
- Not generate non-compliant code
