# R√®gles de d√©veloppement pour ce projet

## Test-Driven Development (TDD)

Toutes les modifications de code sur le abckend doivent suivre le cycle TDD Red-Green-Refactor :

### 1. üî¥ RED - √âcrire le test qui √©choue

- √âcrire le test avant d'impl√©menter la fonctionnalit√©
- Le test doit √©chouer pour la bonne raison (pas d'imports manquants, etc.)
- Le test doit √™tre sp√©cifique et tester une seule chose

### 2. üü¢ GREEN - Impl√©menter le minimum pour faire passer le test

- Impl√©menter uniquement ce qui est n√©cessaire pour que le test passe
- Ne pas ajouter de fonctionnalit√©s suppl√©mentaires
- Le code peut √™tre "sale" tant que le test passe

### 3. üîµ REFACTOR - Am√©liorer le code

- Une fois le test vert, refactoriser le code
- Am√©liorer la lisibilit√©, la performance, la maintenabilit√©
- S'assurer que tous les tests passent toujours apr√®s le refactoring

## R√®gles sp√©cifiques au projet

### Tests

- Les tests unitaires utilisent `@pytest.mark.unit` et n'utilisent PAS le cache Redis
- Les tests d'int√©gration utilisent `@pytest.mark.integration` et utilisent le cache Redis partag√©
- Utiliser `pytest.mark.parametrize` pour √©viter la duplication de code dans les tests

### Cache

- Le cache est d√©sactiv√© pour les tests unitaires (via la fixture `cache` dans `conftest.py`)
- Le cache est partag√© entre les tests d'int√©gration et la production
- Ne pas nettoyer le cache entre les tests (mutualisation avec la prod)

### Code

- Respecter les types Python (typing)
- Documenter les fonctions complexes
- Utiliser des noms de variables et fonctions explicites

## R√®gles du Clean Code

Toutes les modifications de code doivent respecter les principes du clean code suivants :

### 1. √âlimination des nombres magiques (Magic Numbers)

- **JAMAIS** utiliser de nombres magiques directement dans le code
- Cr√©er des constantes nomm√©es dans `backend/domain/constants.py`
- Exemples : `STATION_ID_THRESHOLD = 60000000`, `DEFAULT_MIN_PROFIT_ISK = 100000.0`
- Les constantes doivent √™tre explicites et document√©es

### 2. Fonctions courtes (Small Functions)

- Une fonction doit faire **une seule chose** (Single Responsibility Principle)
- Si une fonction d√©passe 50 lignes, la diviser en sous-fonctions
- Les fonctions doivent √™tre testables individuellement
- Pr√©f√©rer plusieurs petites fonctions qu'une grande fonction

### 3. Nommage explicite (Meaningful Names)

- Les noms de variables, fonctions et classes doivent √™tre **auto-explicatifs**
- √âviter les abr√©viations sauf si elles sont universelles (ex: `id`, `api`)
- Utiliser des verbes pour les fonctions : `calculate_volume()`, `get_item_type()`
- Utiliser des noms de domaine m√©tier quand appropri√©

### 4. DRY (Don't Repeat Yourself)

- **JAMAIS** dupliquer du code
- Extraire la logique commune dans des fonctions utilitaires
- Cr√©er des helpers dans `backend/domain/helpers.py` si n√©cessaire
- R√©utiliser les fonctions existantes plut√¥t que de r√©√©crire la logique

### 4.1. Pr√©f√©rer les fonctions nomm√©es aux commentaires

- **JAMAIS** utiliser un commentaire pour expliquer ce que fait une ligne de code complexe
- Extraire la logique dans une fonction nomm√©e explicite
- Exemple : remplacer `# Filtrer les r√©sultats valides et None` + `deals = [r for r in results if isinstance(r, dict) and r is not None]` par `deals = filter_valid_deals(results)`
- Les fonctions nomm√©es sont auto-document√©es et r√©utilisables
- Si une ligne de code n√©cessite un commentaire, c'est un signe qu'elle devrait √™tre extraite dans une fonction

### 5. Principe de responsabilit√© unique (SRP)

- Chaque classe/fonction doit avoir **une seule raison de changer**
- S√©parer les pr√©occupations : collecte, calcul, formatage, etc.
- Extraire la logique complexe dans des m√©thodes priv√©es (`_method_name`)

### 6. Encapsulation et abstraction

- **Cacher les d√©tails d'impl√©mentation** des couches inf√©rieures
- Les APIs ne doivent **JAMAIS** acc√©der directement aux repositories
- Cr√©er des m√©thodes dans les services pour encapsuler l'acc√®s au repository
- Respecter l'architecture en couches (API ‚Üí Service ‚Üí Repository)

### 7. Documentation et expressivit√©

- Ajouter des **docstrings** uniquement quand n√©cessaire :
  - **TOUJOURS** dans les APIs (endpoints FastAPI) pour g√©n√©rer la documentation OpenAPI
  - **√âVITER** les docstrings redondantes dans le code m√©tier si le nom et les param√®tres sont clairs
- Si une fonction n√©cessite une docstring, c'est peut-√™tre un signe que le nommage peut √™tre am√©lior√©
- Utiliser des commentaires pour expliquer le **pourquoi**, pas le **comment**
- Le code doit √™tre auto-document√© gr√¢ce √† un bon nommage
- Une docstring est inutile si elle r√©p√®te simplement le nom de la fonction et ses param√®tres

### 8. S√©paration des pr√©occupations

- S√©parer les constantes dans `constants.py`
- S√©parer les utilitaires dans `helpers.py`
- La logique m√©tier doit √™tre dans les services, pas dans les APIs
- Chaque module doit avoir une responsabilit√© claire

### 9. Abstraction appropri√©e

- Utiliser le **bon niveau d'abstraction** pour chaque fonction
- Cr√©er des fonctions utilitaires r√©utilisables au lieu de logique inline
- √âviter les niveaux d'abstraction m√©lang√©s dans une m√™me fonction

### 10. Maintenabilit√©

- Le code doit √™tre **facile √† modifier** sans casser d'autres parties
- Centraliser les constantes pour faciliter les changements
- Structurer le code de mani√®re modulaire
- Pr√©f√©rer la composition √† la duplication

### 11. Gestion des imports

- **JAMAIS** importer dans les fonctions (ex: `import logging` dans une fonction)
- Tous les imports doivent √™tre en haut du fichier
- Grouper les imports : standard library, tiers, locaux
- Utiliser des imports absolus pour les modules du projet

### 12. Gestion des erreurs

- √âviter les `except Exception` g√©n√©riques quand possible
- Logger les erreurs avec un contexte appropri√©
- Utiliser des exceptions sp√©cifiques quand c'est possible
- Ne pas masquer les erreurs sans les logger

### Checklist de refactoring

Avant de commiter du code, v√©rifier :

- [ ] Pas de nombres magiques (utiliser des constantes)
- [ ] Fonctions courtes et focalis√©es (< 50 lignes)
- [ ] Noms explicites et significatifs
- [ ] Pas de duplication de code
- [ ] Fonctions nomm√©es plut√¥t que commentaires explicatifs
- [ ] Respect du SRP (une responsabilit√© par fonction/classe)
- [ ] Encapsulation respect√©e (pas d'acc√®s direct aux repositories depuis les APIs)
- [ ] Docstrings uniquement dans les APIs et quand vraiment n√©cessaire (pas de redondance)
- [ ] Imports en haut du fichier uniquement
- [ ] Logique m√©tier dans les services, pas dans les APIs
