# R√àGLES DE D√âVELOPPEMENT - √Ä RESPECTER SYST√âMATIQUEMENT

‚ö†Ô∏è **IMPORTANT** : Ces r√®gles sont OBLIGATOIRES. L'IA doit TOUJOURS les respecter lors de toute modification de code.

## Test-Driven Development (TDD)

**TOUTES** les modifications de code sur le backend doivent suivre le cycle TDD Red-Green-Refactor :

### 1. üî¥ RED - √âcrire le test qui √©choue

**√âTAPE OBLIGATOIRE** : √âcrire le test AVANT d'impl√©menter la fonctionnalit√©.

- Le test doit √©chouer pour la bonne raison (pas d'imports manquants, etc.)
- Le test doit √™tre sp√©cifique et tester une seule chose
- **NE PAS** impl√©menter de code sans avoir √©crit le test d'abord

### 2. üü¢ GREEN - Impl√©menter le minimum pour faire passer le test

**√âTAPE OBLIGATOIRE** : Impl√©menter uniquement le minimum n√©cessaire.

- Impl√©menter uniquement ce qui est n√©cessaire pour que le test passe
- **NE PAS** ajouter de fonctionnalit√©s suppl√©mentaires
- Le code peut √™tre "sale" tant que le test passe

### 3. üîµ REFACTOR - Am√©liorer le code

**√âTAPE OBLIGATOIRE** : Refactoriser apr√®s que le test passe.

- Une fois le test vert, refactoriser le code
- Am√©liorer la lisibilit√©, la performance, la maintenabilit√©
- S'assurer que tous les tests passent toujours apr√®s le refactoring
- Appliquer toutes les r√®gles de clean code ci-dessous

## R√®gles sp√©cifiques au projet

### Tests

- Les tests unitaires n'utilisent PAS le cache Redis
- Les tests d'int√©gration utilisent le cache Redis partag√©. Ne pas nettoyer le cache entre les tests (mutualisation avec la prod).
- Utiliser `pytest.mark.parametrize` pour √©viter la duplication de code dans les tests

### Code

- Respecter les types Python (typing)
- Utiliser des noms de variables et fonctions explicites

## R√àGLES DU CLEAN CODE - √Ä APPLIQUER SYST√âMATIQUEMENT

**TOUTES** les modifications de code doivent respecter les principes du clean code suivants. L'IA doit v√©rifier chaque r√®gle avant de proposer du code.

### 1. √âlimination des nombres magiques (Magic Numbers)

**R√àGLE ABSOLUE** : **JAMAIS** utiliser de nombres magiques directement dans le code.

**ACTION OBLIGATOIRE** :

- Cr√©er des constantes nomm√©es dans `backend/domain/constants.py`
- Exemples : `STATION_ID_THRESHOLD = 60000000`, `DEFAULT_MIN_PROFIT_ISK = 100000.0`
- Les constantes doivent √™tre explicites et document√©es

**EXEMPLE DE VIOLATION** :

```python
# ‚ùå MAUVAIS
if station_id > 60000000:
    # ...

# ‚úÖ BON
from domain.constants import STATION_ID_THRESHOLD
if station_id > STATION_ID_THRESHOLD:
    # ...
```

### 2. Fonctions courtes (Small Functions)

**R√àGLE ABSOLUE** : Une fonction doit faire **une seule chose** (Single Responsibility Principle).

**ACTION OBLIGATOIRE** :

- Si une fonction d√©passe 50 lignes, **LA DIVISER** en sous-fonctions
- Les fonctions doivent √™tre testables individuellement
- Pr√©f√©rer plusieurs petites fonctions qu'une grande fonction

**EXEMPLE DE VIOLATION** :

```python
# ‚ùå MAUVAIS : fonction de 60 lignes
def process_data(data):
    # 60 lignes de code...
    pass

# ‚úÖ BON : divis√©e en sous-fonctions
def process_data(data):
    validated = validate_data(data)
    cleaned = clean_data(validated)
    return transform_data(cleaned)
```

### 3. Nommage explicite (Meaningful Names)

- Les noms de variables, fonctions et classes doivent √™tre **auto-explicatifs**
- √âviter les abr√©viations sauf si elles sont universelles (ex: `id`, `api`)
- Utiliser des verbes pour les fonctions : `calculate_volume()`, `get_item_type()`
- Utiliser des noms de domaine m√©tier quand appropri√©

### 4. DRY (Don't Repeat Yourself)

**R√àGLE ABSOLUE** : **JAMAIS** dupliquer du code.

**ACTION OBLIGATOIRE** :

- Extraire la logique commune dans des fonctions utilitaires
- Cr√©er des helpers dans `backend/domain/helpers.py` si n√©cessaire
- R√©utiliser les fonctions existantes plut√¥t que de r√©√©crire la logique
- Si du code est r√©p√©t√© 2 fois ou plus, l'extraire dans une fonction

### 4.1. Pr√©f√©rer les fonctions nomm√©es aux commentaires

- **JAMAIS** utiliser un commentaire pour expliquer ce que fait une ligne de code complexe
- Extraire la logique dans une fonction nomm√©e explicite
- Exemple : remplacer `# Filtrer les r√©sultats valides et None` + `deals = [r for r in results if isinstance(r, dict) and r is not None]` par `deals = filter_valid_deals(results)`
- Les fonctions nomm√©es sont auto-document√©es et r√©utilisables
- Si une ligne de code n√©cessite un commentaire, c'est un signe qu'elle devrait √™tre extraite dans une fonction

### 5. Principe de responsabilit√© unique (SRP)

- Chaque classe/fonction doit avoir **une seule raison de changer**
- S√©parer les pr√©occupations : collecte, calcul, formatage, etc.
- Extraire la logique complexe dans des m√©thodes priv√©es (`_method_name`)

### 6. Encapsulation et abstraction

- **Cacher les d√©tails d'impl√©mentation** des couches inf√©rieures
- Les APIs ne doivent **JAMAIS** acc√©der directement aux repositories
- Cr√©er des m√©thodes dans les services pour encapsuler l'acc√®s au repository
- Respecter l'architecture en couches (API ‚Üí Service ‚Üí Repository)

### 7. Documentation et expressivit√©

- Ajouter des **docstrings** uniquement quand n√©cessaire :
  - **TOUJOURS** dans les APIs (endpoints FastAPI) pour g√©n√©rer la documentation OpenAPI
  - **√âVITER** les docstrings redondantes dans le code m√©tier si le nom et les param√®tres sont clairs
- Si une fonction n√©cessite une docstring, c'est peut-√™tre un signe que le nommage peut √™tre am√©lior√©
- Utiliser des commentaires pour expliquer le **pourquoi**, pas le **comment**
- Le code doit √™tre auto-document√© gr√¢ce √† un bon nommage
- Une docstring est inutile si elle r√©p√®te simplement le nom de la fonction et ses param√®tres

### 8. S√©paration des pr√©occupations

- S√©parer les constantes dans `constants.py`
- S√©parer les utilitaires dans `helpers.py` quand c'est sp√©cifique au module, dans `backend/utils` quand √ßa peut √™tre partag√© entre plusieurs modules.
- La logique m√©tier doit √™tre dans les services, pas dans les APIs
- Chaque module doit avoir une responsabilit√© claire

### 9. Abstraction appropri√©e

- Utiliser le **bon niveau d'abstraction** pour chaque fonction
- Cr√©er des fonctions utilitaires r√©utilisables au lieu de logique inline
- √âviter les niveaux d'abstraction m√©lang√©s dans une m√™me fonction

### 10. Maintenabilit√©

- Le code doit √™tre **facile √† modifier** sans casser d'autres parties
- Centraliser les constantes pour faciliter les changements
- Structurer le code de mani√®re modulaire
- Pr√©f√©rer la composition √† la duplication

### 11. Gestion des imports

**R√àGLE ABSOLUE** : **JAMAIS** importer dans les fonctions.

**ACTION OBLIGATOIRE** :

- Tous les imports doivent √™tre **EN HAUT DU FICHIER** uniquement
- Grouper les imports : standard library, tiers, locaux
- Utiliser des imports absolus pour les modules du projet

**EXEMPLE DE VIOLATION** :

```python
# ‚ùå MAUVAIS
def my_function():
    import logging  # ‚ùå Import dans une fonction
    logging.info("test")

# ‚úÖ BON
import logging  # ‚úÖ Import en haut du fichier

def my_function():
    logging.info("test")
```

### 12. Gestion des erreurs

- √âviter les `except Exception` g√©n√©riques quand possible
- Logger les erreurs avec un contexte appropri√©
- Utiliser des exceptions sp√©cifiques quand c'est possible
- Ne pas masquer les erreurs sans les logger

## CHECKLIST OBLIGATOIRE AVANT TOUTE MODIFICATION DE CODE

**L'IA DOIT v√©rifier cette checklist avant de proposer du code** :

- [ ] **TDD respect√©** : Test √©crit AVANT l'impl√©mentation (RED ‚Üí GREEN ‚Üí REFACTOR)
- [ ] **Pas de nombres magiques** : Utiliser des constantes de `backend/domain/constants.py`
- [ ] **Fonctions courtes** : Aucune fonction ne d√©passe 50 lignes
- [ ] **Noms explicites** : Variables et fonctions auto-explicatifs
- [ ] **Pas de duplication** : Code r√©utilis√© via des fonctions helpers
- [ ] **Fonctions nomm√©es** : Pas de commentaires explicatifs, extraire en fonctions
- [ ] **SRP respect√©** : Une seule responsabilit√© par fonction/classe
- [ ] **Encapsulation** : Pas d'acc√®s direct aux repositories depuis les APIs
- [ ] **Docstrings** : Uniquement dans les APIs (FastAPI) et si vraiment n√©cessaire
- [ ] **Imports en haut** : Tous les imports en haut du fichier uniquement
- [ ] **Logique m√©tier** : Dans les services, pas dans les APIs
- [ ] **Gestion d'erreurs** : Exceptions sp√©cifiques, pas de `except Exception` g√©n√©rique
- [ ] **Formatage Ruff** : Ex√©cuter `ruff format` sur tous les fichiers modifi√©s du backend apr√®s chaque modification

## INSTRUCTIONS POUR L'IA

**AVANT de proposer du code, l'IA DOIT** :

1. **Lire cette checklist compl√®te**
2. **V√©rifier chaque point** avant de g√©n√©rer du code
3. **Appliquer syst√©matiquement** toutes les r√®gles
4. **Refuser** de g√©n√©rer du code qui viole ces r√®gles
5. **Proposer des corrections** si le code existant viole les r√®gles

**APR√àS avoir modifi√© du code dans le backend, l'IA DOIT** :

1. **Ex√©cuter Ruff format automatiquement** sur tous les fichiers Python modifi√©s
2. **Commande √† ex√©cuter** : `ruff format <fichier1> <fichier2> ...` pour chaque fichier modifi√© dans `backend/`
3. **V√©rifier** que le formatage est appliqu√© avant de finaliser les modifications
4. **Ne jamais** proposer de code non format√© avec Ruff

**Si l'utilisateur demande quelque chose qui viole ces r√®gles, l'IA DOIT** :

- Expliquer pourquoi la demande viole les r√®gles
- Proposer une alternative conforme aux r√®gles
- Ne pas g√©n√©rer de code non conforme
